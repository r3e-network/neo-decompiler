#!/usr/bin/env python3
"""
Generate Rust lookup tables for Neo N3 syscalls by scraping the upstream
ApplicationEngine partial classes.
"""

import base64
import hashlib
import json
import re
import urllib.request
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable

REPO_ROOT = Path(__file__).resolve().parents[1]
LOCAL_BASE = REPO_ROOT / "neo_csharp" / "core" / "src" / "Neo" / "SmartContract"
API_BASE_URL = "https://api.github.com/repos/neo-project/neo/contents/src/Neo/SmartContract/"
FILES = [
    "ApplicationEngine.Runtime.cs",
    "ApplicationEngine.Contract.cs",
    "ApplicationEngine.Crypto.cs",
    "ApplicationEngine.Storage.cs",
    "ApplicationEngine.Iterator.cs",
]

OUTPUT = REPO_ROOT / "src" / "syscalls_generated.rs"


@dataclass
class Syscall:
    name: str
    handler: str
    price: str
    call_flags: str
    returns_value: bool

    @property
    def hash_value(self) -> int:
        digest = hashlib.sha256(self.name.encode("ascii")).digest()
        return int.from_bytes(digest[:4], "little")

    def as_dict(self) -> dict:
        return {
            "name": self.name,
            "handler": self.handler,
            "price": self.price,
            "call_flags": self.call_flags,
            "hash": self.hash_value,
            "returns_value": self.returns_value,
        }


REGISTER_PATTERN = re.compile(
    r'Register\("(?P<name>[^"]+)",\s*(?:nameof\()?(?P<handler>[A-Za-z0-9_\.]+)\)?\s*,\s*(?P<price>[^,]+),\s*(?P<flags>CallFlags\.[A-Za-z0-9_\s|&^\.]+)(?:,\s*Hardfork\.[A-Za-z0-9_]+)?\)',
    re.MULTILINE,
)


def read_local(path: str) -> str | None:
    local_path = LOCAL_BASE / path
    if local_path.exists():
        return local_path.read_text(encoding="utf-8")
    return None


def fetch(path: str) -> str:
    url = f"{API_BASE_URL}{path}?ref=master"
    headers = {
        "User-Agent": "neo-decompiler/0.1",
        "Accept": "application/vnd.github+json",
    }
    for attempt in range(3):
        try:
            req = urllib.request.Request(url, headers=headers)
            with urllib.request.urlopen(req) as resp:  # type: ignore[arg-type]
                payload = json.loads(resp.read().decode("utf-8"))
            if payload.get("encoding") != "base64":
                raise ValueError(f"unexpected encoding for {path}")
            content = base64.b64decode(payload["content"])
            return content.decode("utf-8")
        except urllib.error.URLError:  # type: ignore[attr-defined]
            if attempt == 2:
                raise
    raise RuntimeError(f"unreachable: failed to fetch {path}")


def load_source(path: str) -> str:
    local = read_local(path)
    if local is not None:
        return local
    return fetch(path)


def parse_registers(text: str) -> Iterable[Syscall]:
    for match in REGISTER_PATTERN.finditer(text):
        name = match.group("name")
        handler = match.group("handler")
        price = " ".join(match.group("price").split())
        flags = " ".join(match.group("flags").split())
        returns_value = not returns_void(name)
        yield Syscall(
            name=name,
            handler=handler,
            price=price,
            call_flags=flags,
            returns_value=returns_value,
        )


def collect_syscalls() -> list[Syscall]:
    entries: dict[str, Syscall] = {}
    for file in FILES:
        try:
            text = load_source(file)
        except urllib.error.HTTPError as exc:  # type: ignore[attr-defined]
            raise SystemExit(f"failed to fetch {file}: {exc}") from exc
        for syscall in parse_registers(text):
            entries.setdefault(syscall.name, syscall)
    return sorted(entries.values(), key=lambda s: (s.hash_value, s.name))


RUST_TEMPLATE = """// This file is @generated by tools/scrape_syscalls.py. Do not edit manually.

pub struct SyscallInfo {{
    pub hash: u32,
    pub name: &'static str,
    pub handler: &'static str,
    pub price: &'static str,
    pub call_flags: &'static str,
    pub returns_value: bool,
}}

pub const SYSCALLS: &[SyscallInfo] = &[
{entries}
];
"""


def render_entry(syscall: Syscall) -> str:
    return (
        f"    SyscallInfo {{ hash: 0x{syscall.hash_value:08X}, "
        f"name: \"{syscall.name}\", "
        f"handler: \"{syscall.handler}\", "
        f"price: \"{syscall.price}\", "
        f"call_flags: \"{syscall.call_flags}\", "
        f"returns_value: {str(syscall.returns_value).lower()} }},"
    )


def returns_void(name: str) -> bool:
    # Minimal allowlist; expand as upstream adds metadata.
    return name in {
        "System.Runtime.Notify",
        "System.Runtime.Log",
        "System.Runtime.BurnGas",
        "System.Storage.Put",
        "System.Storage.Delete",
        "System.Storage.Local.Put",
        "System.Storage.Local.Delete",
        "System.Contract.NativePostPersist",
        "System.Contract.NativeOnPersist",
    }


def main() -> None:
    syscalls = collect_syscalls()
    entries = "\n".join(render_entry(s) for s in syscalls)
    OUTPUT.write_text(RUST_TEMPLATE.format(entries=entries))
    meta = [s.as_dict() for s in syscalls]
    data_dir = REPO_ROOT / "tools" / "data"
    data_dir.mkdir(parents=True, exist_ok=True)
    (data_dir / "syscalls.json").write_text(json.dumps(meta, indent=2))
    print(f"wrote {OUTPUT} ({len(syscalls)} entries)")


if __name__ == "__main__":
    main()
